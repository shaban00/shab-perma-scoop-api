"""
`models.capture` module: Class to interact with the "capture" table.
"""

from __future__ import annotations

import datetime
import json
import time
import uuid

from flask import current_app, jsonify
import peewee
from playhouse.postgres_ext import JSONField
import requests
from requests import Response

from scoop_rest_api.models import AccessKey
from scoop_rest_api.utils import capture_to_dict, get_db


class Capture(peewee.Model):
    """
    "capture" table definition. Helps keep trace of capture processes.
    """

    id_capture = peewee.UUIDField(primary_key=True, null=False, default=uuid.uuid4)

    id_access_key = peewee.ForeignKeyField(model=AccessKey, field="id_access_key", index=True)

    created_timestamp = peewee.TimestampField(utc=True, resolution=1000, null=False)

    started_timestamp = peewee.TimestampField(
        utc=True, resolution=1000, null=True, default=None, index=True
    )

    ended_timestamp = peewee.TimestampField(
        utc=True, resolution=1000, null=True, default=None, index=True
    )

    url = peewee.TextField(null=False)

    callback_url = peewee.TextField(null=True)

    options = JSONField(null=True)
    """JSON object for additional options and parameters (TBD)."""

    status = peewee.CharField(
        max_length=16,
        choices=["pending", "started", "failed", "success"],
        default="pending",
        index=True,
    )
    """Current status can be: "pending", "started", "failed"."""

    stdout_logs = peewee.TextField(null=True)
    """STDOUT Logs generated by the capture software."""

    stderr_logs = peewee.TextField(null=True)
    """STDERR Logs generated by the capture software."""

    summary = JSONField(null=True)
    """JSON object summarizing capture info."""

    archive = peewee.BlobField(null=True)
    """ The captured archive itself. """

    attachments = peewee.BlobField(null=True)
    """ Effectively a zip file of attachments. """

    class Meta:
        table_name = "capture"
        database = get_db()

    # Settings to allow our tests to draw out race conditions
    TEST_PAUSE_TIME = 0
    TEST_ALLOW_RACE = False

    @classmethod
    def get_next_capture(cls, reserve: bool = False) -> Capture | None:
        """Get the next pending capture from the database.

        Optionally reserves the capture by marking it as started; this
        removes it from the queue and ensures it won't be retrieved
        twice.

        Returns None if no pending capture is available.
        """
        capture: Capture | None = (
            cls.select()
            .where(cls.status == "pending")
            .order_by(cls.created_timestamp)
            .paginate(1, 1)
            .get_or_none()
        )

        # Reserve capture if requested
        if (reserve is True) and (capture is not None):
            if cls.TEST_PAUSE_TIME > 0:
                time.sleep(cls.TEST_PAUSE_TIME)

            update_count = (
                Capture.update(status="started")
                .where(Capture.id_capture == capture.id_capture, Capture.status == "pending")
                .execute()
            )

            if (update_count < 1) and (cls.TEST_ALLOW_RACE is not True):
                current_app.logger.warning(
                    f"Capture #{capture.id_capture} | Capture already running in another process: status already updated."
                )
                return None

            # Refresh capture
            capture = Capture.get(Capture.id_capture == capture.id_capture)
            capture.started_timestamp = datetime.datetime.now(datetime.UTC)
            capture.save()
            current_app.logger.info(f"Capture #{capture.id_capture} | Marked as started")

        return capture

    def call_callback_url(self) -> Response | None:
        """Post a request to this capture's webhook URL."""
        current_app.logger.info(f"Capture #{self.id_capture} | Callback to {self.callback_url}")
        try:
            # Workaround to use Flask's jsonify, for consistency across the app
            json_data = json.loads(jsonify(capture_to_dict(self)).data.decode("utf-8"))
            response = requests.post(self.callback_url, json=json_data, timeout=10)
        except Exception:
            current_app.logger.exception(
                f"Capture #{self.id_capture} | Callback to {self.callback_url} failed"
            )
            return None
        else:
            return response
